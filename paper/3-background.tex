\section{Background \& Related Work}
\label{sec:background}

\todo{merge Related work and Background}

We begin with a brief background on relevant topics as we motivate the need for
fast and scalable co-residence detection in lambdas.

\subsection{Lambdas/Serverless Functions} 
\label{sec:background:lambdas}

We focus on serverless functions in this paper, as they are one of the
fastest-growing cloud services and are less well-studied from a security
standpoint. Offered as lambdas on AWS~\cite{awslambda}, and as cloud functions
on GCP~\cite{gcpfunctions} and Azure~\cite{azurefunctions}, these functions are
of interest because they do not require the developer to provision, maintain, or
administer servers. In addition to this low overhead, lambdas are much more
cost-efficient than virtual machines (VMs) as they allow more efficient packing
of functions on servers. Moreover, lambdas execute as much smaller units  and
are more ephemeral than virtual machines.  For example, on AWS,
the memory of lambdas is capped at 3 GB, with a maximum execution limit of 15
minutes.  As with other cloud services, the user has no control over the
physical location of the server(s) on which their lambdas are spawned.

While lambdas are limited in the computations they can execute (typically
written in high-level languages like Python, C\#, etc), they are conversely
incredibly lightweight and can be initiated and deleted in a very short amount
of time. Cloud providers run lambdas in dedicated containers with limited
resources (e.g., Firecracker ~\cite{firecracker}), which are usually cached and
re-used for future lambdas to mitigate cold-start
latencies~\cite{awscontainerreuse}. The ephemeral nature of serverless functions
and their limited flexibility increases the difficulty in detecting
co-residency, as we will discuss later. While previous studies that profiled
lambdas~\cite{wangusenix2018} focused on the performance aspects like cold start
latencies, function instance lifetime, and CPU usage across various clouds,
the security aspects remain relatively understudied.


\subsection{Covert Channels in the Cloud}
\label{sec:background:covertchannels}
In our attempt to shed light on the security aspects of lambdas, we focus
particularly on the feasiblity of establishing a reliable covert channel in the
cloud using lambdas.  Covert channels enable a means of transmitting information
beween entities that bypasses traditional monitoring or auditing. Typically,
this is acheived by communicating data across unintended channels such as
signalling bits by causing contention on shared hardware media on the
server~\cite{L2cacheCovertChannels,
ProcessorCovertChannels,ThermalCovertChannel,SshOverCovertChannel,wuusenix2012}.
Past work has demonstrated covert channels in virtualized environments like the
clouds using various harware such as
caches~\cite{ristenpartccs2009,L2cacheCovertChannels}, memory
bus~\cite{wuusenix2012}, and even processor
temperature~\cite{ThermalCovertChannel}. \\

\noindent \textbf{Memory bus covert channel} 
Of particular interest to this work is the covert channel based on memory bus 
hardware introduced by Wu et al.~\cite{wuusenix2012}. 
In x86 systems, atomic memory instructions designed to facilitate 
multi-processor synchronization are supported by cache coherence protocols as
long as the operands remain within a cache line (generally the case as language
compilers make sure that operands are aligned). However, if the operand is
spread across two cache lines (referred to as "exotic" memory operations), x86
hardware achieves atomicity by locking the memory bus to prevent any other
memory access operations until the current operation finishes. This results in
significantly higher latencies for such locking operations compared to traditional 
memory accesses. As a result, a few consecutive locking operations could cause 
contention on the memory bus that could be exploited for covert communication.
Wu et al. acheived a data rate of 700 bps on the memory bus channel in an 
ideal laboratory setup.

Achieving such ideal performance, however, is generally not possible in cloud 
environments, as they pose challenges to both establishing such covert
channels and using them at their ideal performance. \del{First, in a cloud setting,
co-residency information is hidden, even if the entities belong to the same
tenant, so it is unclear whether a sender and receiver are on the same server.}
Communication on the covert channel may be affected by
scheduling uncertainties and interference from other non-participating
workloads due to statistical multiplexing by the cloud providers.  Studies
generally deal with this problem by employing traditional error correction
techniques~\cite{wuusenix2012} to overcome errors.  \del{However, the former
challenge of establishing the covert channel requires a co-residence detection
mechansim which the attacker needs to employ to ensure the sender and receiver
are on the same machine.}


\subsection{Co-residence Detection}
\label{sec:background:pastwork}

%On previous work on colocation, past techniques and why those techniques would 
%not work anymore
\ins{In the cloud context, enabling covert communication comes with an additional 
challenge of locating sender and receiver on the same machine so that both 
can have access to the shared software or hardware-based covert channel. However,
such co-residency information is hidden, even if the entities belong to the same
tenant.} Past research has used various strategies to achieve co-residency in order 
to demonstrate various covert channel attacks in the cloud. Typically, the
attacker launches a large number of cloud instances (VMs, Lambdas, etc.),
following a certain launch pattern, and employs a co-residence detection
mechanism for detecting if any pair of those instances are running on the same
machine. Traditionally, co-residence detection has been based on software
runtime information that two instances running on the same server might share,
like public/internal IP addresses~\cite{ristenpartccs2009}, files in
\textit{procfs} or other environment
variables~\cite{wangusenix2018,wuusenix2012}, and other such logical
side-channels~\cite{varad191016,vmplacement}.

As virtualization platforms moved towards stronger isolation between instances (e.g.
AWS' Firecracker VM~\cite{firecracker}), these logical covert-channels have
become less effective or infeasible. Furthermore, some of these channels were
only effective on container-based platforms that shared the underlying OS image
and were thus less suitable for hypervisor-based platforms.  This prompted a
move towards using hardware-based covert channels, such as the ones discussed in
the earlier section, which can bypass software isolation and are usually harder
to fix. For example, Varadarajan et al.~\cite{varadarajan2015} use the memory
bus covert channel to detect co-residency for EC2 instances.  However, as we
will show, traditional approaches do not extend well to lambdas as they are either too
slow or are not scalable. \del{Thus, we set forth to determine a fast and scalable
co-residence detection for lambdas.}


\section{Attack Strategy}
\label{sec:attackstrategy}
\subsection{Attack Model}
\subsection{Enabling Covert Communication}

\ins{<SUPER ROUGH> Our goal is to figure out a feasible covert communication mechanism for lambdas.
As mentioned earlier, there are few unique challenges to extend traditional covert 
channel work to the cloud: First, we need a co-residence detector to co-locate both 
sender and receiver on same server. Second, statistical multiplexing introduces both 
noisy neighbors and inconsistent access to the channel that is dependant on the scheduler 
behavior. Both these challenges has been handled for VMs independently in previous work.
For example, in case of VMs, sender and receiver can be colocated using co-residence strategies 
like \cite{varadarajan2015}. Once colocated, they can communicate information using one of the 
traditional covert channels, but improved to address scheduler interruptions and other noise 
using error detection and correction techniques\cite{wuusenix2012}.}

\ins{Lambdas, however, are different from other container platforms like VMs in that 
they have very short lifetime and a covert channel communication between two co-resident 
lambdas cannot last very long. But what they lack in persistence, they make up for 
in numbers -- lambdas are usually deployed in large numbers. So, any practical design for 
covert channel targeting lambdas must exploit this fact and perform communication 
over multiple channels in parallel to acheive high bandwidth. 
Based on the threat model, it follows that an attacker attempting to 
maximize covert communication with lambdas would deploy a large number of sender and 
receiver lambdas in the Cloud hoping to acheive multiple rendezvous points for 
covert communication. Lambdas are also densely packed, which we will show later, that 
exacerbates the noisy neighbor problem if the other neighbors are not properly detected}

\ins{<SUPER DUPER ROUGH> This brings us to our contributions in this paper. Where lambdas are similar to 
VMs, we use the previous work. Where they are different and present new challenges, 
we focus on addressing these. The ephemeral, numerous and dense nature of lambdas require (respectively) 
a fast, scalable and reliable co-residence detector which is going to be the main contribution of 
our work. Once colocated, our detector allows us to pick any just two lambdas on any given machine 
and use the covert channel without interference from neighbors. At this point, covert channel works
for VMs like Wu et. al.\cite{wuusenix2012}  can be comfortably used for covert communication 
with lambdas as well. In the next section, we propose and evaluate our coresidence detector 
and show how it enables covert communication with lambdas.}
