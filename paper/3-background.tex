\section{Background \& Related Work}
\label{sec:background}

We begin with a brief discussion on background and related work as we motivate
the need for fast and scalable co-residence detection in lambdas.

\subsection{Lambdas/Serverless Functions} 
\label{sec:background:lambdas}

We focus on serverless functions in this paper, as they are one of the
fastest-growing cloud services and are less well-studied from a security
standpoint. Offered as lambdas on AWS~\cite{awslambda} and as cloud functions
on GCP~\cite{gcpfunctions} and Azure~\cite{azurefunctions}, these functions are
of interest because they do not require the developer to provision, maintain, or
administer servers. In addition to this low overhead, lambdas are much more
cost-efficient than virtual machines (VMs) as they allow more efficient packing
of functions on servers. Moreover, lambdas execute as much smaller units  and
are more ephemeral than virtual machines.  For example, on AWS,
the memory of lambdas is restricted to 3 GB, with a maximum execution limit of 15
minutes.  As with other cloud services, the user has no control over the
physical location of the server(s) on which their lambdas are spawned.

While lambdas are limited in the computations they can execute (typically
written in high-level languages like Python, C\#, etc), they are conversely
incredibly lightweight and can be initiated and deleted in a very short amount
of time. Cloud providers run lambdas in dedicated containers with limited
resources (e.g., Firecracker ~\cite{firecracker}), which are usually cached and
re-used for future lambdas to mitigate cold-start
latencies~\cite{awscontainerreuse}. The ephemeral nature of serverless functions
and their limited flexibility increases the difficulty in detecting
co-residency, as we will discuss later. 

Previous studies have focused on a variety of aspects of lambdas, such as
performance aspects~\cite{wangusenix2018} or cost efficiency when compared to
other application in the cloud or batching data processing~\cite{villamizar2016,
kiran2015}. From a security perspective, Izhikevich et.  al examined lambda
co-residency using RNG and memory bus techniques (similar to techniques utilized
in VM co-residency)~\cite{izhikevich2018}. However, our work differs from this
study in that our technique informs the user of which lambdas are on the same
machine, not only that the lambdas experience co-residency.

%Recent studies examined cost comparisons of running web
%applications in the cloud on lambdas versus other
%architectures~\cite{villamizar2016}, and also examined the lambdas have been
%studied in the context of cost-effectivness of batching and data processing with
%lambdas~\cite{kiran2015}.  Further research has shown how lambdas perform with
%scalability and hardware isolation, indicating some flaws in the lambda
%architecture~\cite{wangusenix2018}. 
%focused on
%the performance aspects like cold start latencies, function instance lifetime,
%and CPU usage across various clouds, the security aspects remain relatively
%understudied. 


\subsection{Covert Channels, Cloud Attacks, and Co-residence}
\label{sec:background:covertchannels}
In our attempt to shed light on the security aspects of lambdas, we focus
particularly on the feasiblity of establishing a reliable covert channel in the
cloud using lambdas.  Covert channels enable a means of transmitting information
beween entities that bypasses traditional monitoring or auditing. Typically,
this is acheived by communicating data across unintended channels such as
signalling bits by causing contention on shared hardware media on the
server~\cite{L2cacheCovertChannels,
ProcessorCovertChannels,ThermalCovertChannel,SshOverCovertChannel,wuusenix2012}.
Past work has demonstrated covert channels in virtualized environments like the
clouds using various harware such as
caches~\cite{ristenpartccs2009,L2cacheCovertChannels}, memory
bus~\cite{wuusenix2012}, and even processor
temperature~\cite{ThermalCovertChannel}. 

Initial papers in co-residency detection utilized host information and network
addresses arising due to imperfect virtualization~\cite{ristenpartccs2009} and
utilized files in \textit{procfs}, other environment
variables~\cite{wangusenix2018,wuusenix2012}, and other logical
side-channels~\cite{varad191016,vmplacement}.  Much of this work has been
further extended to examine co-residence in active traffic
analysis~\cite{bates2012}, as well as determining placement vulnerabilities in
multi-tenant Public Platform-as-a-Service systems~\cite{varad191016,
zhangpaas2016}. 

However, these channels are now obsolete, as cloud provides have strengthened
virtualization and introduced Virtual Private Clouds~\cite{awsvpc}. Later work
used cache-based channels in various levels of the cache~\cite{xuccsw2011,
zhangccs2014, liu2015, kaylaap2016} and hardware based channels like thermal
covert channels~\cite{mastiusenix2015}, RNG module~\cite{evtyushkinccs2016} and
memory bus~\cite{wuusenix2012} have also been explored in the recent past.
Moreover, studies have found that VM performance can be significantly degraded
using memory DDoS attacks~\cite{zhang2016memory}, while containers are
susceptible to power attacks from adjacent containers~\cite{gao2017}.  


\noindent \textbf{Memory bus covert channel} 
Of particular interest to this work is the covert channel based on memory bus
hardware introduced by Wu et al.~\cite{wuusenix2012} and subsequently used for
co-residency detection on VMs~\cite{varad191016}. In x86 systems, atomic
memory instructions designed to facilitate multi-processor synchronization are
supported by cache coherence protocols as long as the operands remain within a
cache line (generally the case as language compilers make sure that operands are
aligned). However, if the operand is spread across two cache lines (referred to
as "exotic" memory operations), x86 hardware achieves atomicity by locking the
memory bus to prevent any other memory access operations until the current
operation finishes. This results in significantly higher latencies for such
locking operations compared to traditional memory accesses. As a result, a few
consecutive locking operations could cause contention on the memory bus that
could be exploited for covert communication.  Wu et al. acheived a data rate of
700 bps on the memory bus channel in an ideal laboratory setup.

%Covert channels using memory bus were first
%introduced by Wu et. al~\cite{wuusenix2012}, and subsequently has been used for
%co-residency detection on VMs and
%containers~\cite{compstudycoresidency,varad191016}  Wu et. al~\cite{wuusenix2012}
%introduced a new technique to lock the memory bus by using atomic memory
%operations on addresses that fall on multiple cache lines, a technique we rely
%on in our own work. \\

Achieving such ideal performance, however, is generally not possible in cloud
environments, as they pose challenges to both establishing such covert channels
and using them at their ideal performance. 
%\del{First, in a cloud setting, co-residency information is hidden, even if the
%entities belong to the same tenant, so it is unclear whether a sender and
%receiver are on the same server.}
Communication on the covert channel may be affected by scheduling uncertainties
and interference from other non-participating workloads due to statistical
multiplexing by the cloud providers.  Studies generally deal with this problem
by employing traditional error correction techniques~\cite{wuusenix2012} to
overcome errors. 

%\del{However, the former
%challenge of establishing the covert channel requires a co-residence detection
%mechansim which the attacker needs to employ to ensure the sender and receiver
%are on the same machine.}


%\subsection{Co-residence Detection}
%\label{sec:background:pastwork}
%
%
%%On previous work on colocation, past techniques and why those techniques would 
%%not work anymore
%%as a sender and receiver
%%on the same machine can access the covert channel and share information.
%Co-residence detection can enable covert communication however, a challenge is
%locating the sender and receiver, as this co-residency information is often
%hidden, even if entities belong to the same tenant.  Typically, the attacker
%launches a large number of cloud instances (VMs, Lambdas, etc.), following a
%certain launch pattern, and employs a co-residence detection mechanism for
%detecting if any pair of those instances are running on the same machine.
%Traditionally, co-residence detection has been based on software runtime
%information that two instances running on the same server might share, like
%public/internal IP addresses~\cite{ristenpartccs2009}, files in \textit{procfs}
%or other environment variables~\cite{wangusenix2018,wuusenix2012}, and other
%such logical side-channels~\cite{varad191016,vmplacement}. 
%
%Much of this work has been further extended to examine co-residence in active
%traffic analysis~\cite{bates2012}, as well as determining placement
%vulnerabilities in multi-tenant Public Platform-as-a-Service
%systems~\cite{varad191016, zhangpaas2016}. 
%
%%Zhang et al. also demonstrated a technique to detect VM
%%co-residency detection via side-channel analyses~\cite{zhang2011}. 
%%One of the first pieces of literature in detecting VM co-residency was
%%introduced by Ristenpart et al., who demonstrated that VM co-residency detection
%%was possible and that these techniques could be used to gather information about
%%the victim machine (such as keystrokes and network
%%usage)~\cite{ristenpartccs2009}. This initial work was further expanded in
%%subsequent years 
%As virtualization platforms moved towards stronger isolation between instances
%(e.g.  AWS' Firecracker VM~\cite{firecracker}), these logical covert-channels
%have become less effective or infeasible. Furthermore, some of these channels
%were only effective on container-based platforms that shared the underlying OS
%image and were thus less suitable for hypervisor-based platforms.  This prompted
%a move towards using hardware-based covert channels, such as the ones discussed
%in the earlier section, which can bypass software isolation and are usually
%harder to fix. 


\section{Threat Model}
\label{sec:attackstrategy}
\amirian{I was trying to keep these are two separate subsections but I didnt
like how it was flowing. I think just putting them together makes more sense
(and less awkward transitions), but Im open to feedback on this!}

%\subsection{Enabling Covert Communication}
%\todo{rename to motivation?}

The goal of our attacker is to use a covert communication mechanism via lambdas.
As mentioned earlier, there are few unique challenges to extending traditional
covert channel work to the cloud. We need: 1) a co-residence detector to
co-locate two instances on a server and 2) to handle statistical multiplexing
that introduces noisy neighbors and inconsistent access to the channel.

While these challenges have been handled for VMs (see related work), lambdas are
inherently different that VMs in that they have very short lifetimes. A covert
channel between two co-resident lambdas will not last very long. However, while
lambdas lack in persistence, it is trivial to launch lambdas in large numbers at
once. However, though large numbers of lambdas allow for more covert communication,
lambdas are also densly packed (discussed later) exacerbating the noisy
neighbor problem.

The ephemeral, numerous and dense nature of lambdas require a fast,
scalable, and reliable co-residence detector, which is the main contribution of
our work. Once co-located, our detector protocol allows an attacker to pick any
two lambdas on a given machine, and use the covert channel without interference
from neighbors.

\amirian{...I am blanking on why the covert channel helps an attacker in this
scenario. I might have an outdated mentalmodel}
This definition of capabilities leads us to defining our attacker model.
Our attacker\'s end goal is to use lambdas to covertly communicate and to
wreak blind havoc on other consumers on the cloud service. Our attacker can
create as many lambdas as they want and, using the co-residence locator, can
quickly determine which of their lambdas are co-resided on the same machine.
This means that they can quickly identify which lambdas are singletons and save
time and money by killing these functions early. Moreover, with the lambdas
clusters that are identified, the attacker can wreak blind havoc\todo{how?}.
