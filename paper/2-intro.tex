\section{INTRODUCTION}
\label{sec:intro}

% generally coresidence implies getting an attacker VM colocated with 
% a victim VM - we are not doing that 
% rather we are providing a tool for colocating our own apps 
% in particular, we are figuring out with certainty which of our apps 
% are colocated with others
% 1. we can present it as a tool to aid the isolation, placement 
% and scheduling studies as software-based strategies become infeasible
% due to better isolation strategies
% 2. We prove that an attacker can reliably colocate a bunch of its 
% instances which may facilitate her in much more targeted DDos attacks 
% (find some references) 
% 3. (Speculative) figuring out migration strategies of 
% VMs/containers if deployed on a larger scale might aid in coordinated attacks 
% a la power attacks.
% we present technique as our main contribution for now
% a better way would be use this technique to get some interesting 
% new results and present that as the main contribution


%% Paragraph 1: Introduce cloud computing and the problem of cartography
\amirian{edits for intro starting here}
Cloud computing is a fast growing technology that is widely used around the
globe~\todo{cite; can also throw in numbers to make  this more convincing}.
Major cloud providers like AWS~\cite{awscloud}, Microsoft
Azure~\cite{azurecloud} and Google Cloud~\cite{googlecloud} provide a multitude
of compute and storage services and have seen immense growth over the past
decade~\todo{cite}. While there are many benefits of using cloud services, like
increased scalability and decreased IT costs~\cite{Armbrust}, the cloud also
creates new security concerns as multiple tenants share the same underlying
physical infrastructure. For example, by multiplexing applications from multiple
tenants on the same server, cloud computing opens up new avenues and
opportunities for side-channel attacks through shared server hardware like
caches~\cite{meltdown, xuccsw2011}.  


%While the virtualization platforms used to
%share the infrastructure have been constantly improving to harden the isolation
%between the tenants, this process usually comes at the cost of performance and
%are not flawless\amirian{better?}\todo{cite, HELP!}.


% Why another coresidence detection technique
Traditionally, clouds have relied on hiding their placement mechanisms (i.e.,
how they pack tenants onto servers) and co-residence information (i.e., which
particular tenants are placed together on a server) as a first line of defense
against targeted attacks. By reducing an attacker's ability to identify and
target the same server as their victim, attackers may have to execute
brute-force mechanisms that can become expensive with low yield.  A plethora of
previous work, started by Ristenpart et al.~\cite{ristenpartccs2009}, have
exploited various covert channels to achieve co-residency detection on clouds
like AWS. Prior studies then used these channels to demonstrate targeted attacks
or shed light on cloud's internal placement and resource allocation
mechanisms\todo{cite}, which further weaken the cloud encapsulation model. Cloud
providers have since promptly fixed many of these covert channels and produced
solutions (e.g. containers) that provide better isolation, like AWS
Firecracker\cite{firecracker}. However, we find that these encapsulations remain
imperfect.


% What's special about our technique
In this work, we find yet another co-residency detection mechanism among cloud
instances by utilizing the memory bus hardware, first introduced by Wu et.
al~\cite{wuusenix2012}.  The memory bus covert-channel is more pervasive,
reliable, and harder to fix than previous approaches, and we show that is is
omni-present on all major cloud providers. Unlike software-based covert channels
that can be fixed with new releases, the memory bus is inherent to x86 hardware
and is harder to fix.  Finally, while previous approaches have made simplistic
uses of this covert channel~\cite{varadarajan2015}, we overcome previous
challenges of noise and synchronization issues to transmit bits reliably, which
enables us to achieve fast co-location detection for thousands of cloud
instances.

% Why lambdas
In this paper, we focus on serverless functions, which have experienced an
increased interest and growth in recent years, but also come with their own
unique challenges. Due to their popularity (with flexibility in scheduling and
low overhead), most cloud services now provide these serverless functions to
developers; AWS calls these serverless functions lambdas~\cite{awslambda} while
GCP refers to them as cloud functions~\cite{gcpfunctions}\footnote{Note that in
this work, we use the terms lambdas, serverless functions, and cloud instances
interchangeably hereafter}.  While the flexibility and low overhead are
attributes that appeal to developers, the converse is that information about
lambda placement is not readily available, and lambdas have restricted runtimes
that limit low-level code often used in co-residency detection, making
co-residence detection more difficult. Moreover, lambdas are also more ephemeral
(running for a maximum of 15 minutes), forcing any potential co-residence
detection to be faster than previously known mechanisms. 

%\amirian{this sentence feels awkward}Since other
%tradition containers are less restrictive, lambda co-location detection can be
%replicated easily in these other environments.

% Summary of what we did
Even given these constraints, we demonstrate a technique that determines
\emph{co-operative} co-location for a given set of 1.5 GB (or larger) lambdas
with a 100\% success rate.  In a co-operative setting, all lambdas are assumed
to be in the attacker's control, and still allow the attacker to perform DDoS
attacks or learn the cloud's internal mechanisms.  Furthermore, we can achieve
this 100\% successful co-location detection within a minute for thousands of
lambdas. Our technique is not only scalable and reliable, but has accurate
sampling frequency and duration, and is able to overcome noise in the
measurements.  We also perform a measurement study on colocation patterns in
various AWS regions with some insights on lambda activity. \todo{add more
concrete takeaways} Through this, we hope to motivate the need to address the
memory bus covert channel in all the three clouds, and prove that encapsulation
is an ever changing landscape.



% Organization
The remainder of this paper is organized as follows. Section
\ref{sec:background} presents some background from the literature. Sections
\ref{sec:methodology} and \ref{sec:technique} present our co-residence detection
mechanism in detail. We evaluate the mechanism in section \ref{sec:eval} and
conclude with a placement study of AWS lambdas using our technique in section
\ref{sec:study}.  

\amirian{edits for intro end here}
Cloud computing is a fast growing technology that is being widely used 
around the globe~\todo{cite; can also throw in numbers to make  this 
more convincing}. Major cloud providers like AWS~\cite{awscloud}, 
Microsoft Azure~\cite{azurecloud} and Google Cloud~\cite{googlecloud} 
provide a multitude of compute and storage services and have seen 
immense growth over the past decade~\todo{cite}. While there are many 
benefits of using cloud services, like increased scalability and 
decreased IT costs~\cite{Armbrust}, cloud also brings new security 
concerns to the table as multiple tenants share the same underlying 
physical infrastructure. 
For example, by multiplexing applications from multiple tenants on 
the same server, cloud computing opens up new avenues and opportunities 
for side-channel attacks through shared server hardware like 
caches~\cite{meltdown, xuccsw2011}. While the virtualization platforms 
used to share the infrastructure have been constantly improving to harden 
the isolation between the tenants, it's a never ending process and new 
attack surfaces keep showing up \todo{cite, HELP!}. Also, hardening isolation 
usually comes 
at the cost of performance which may offset the benefits of sharing 
the infrastructure that enabled cloud computing in the first place.


% Why another coresidence detection technique
Traditionally, clouds have relied on hiding their placement mechanisms (i.e., 
how they pack tenants onto their servers) and coresidence information (i.e., which 
particular tenants are packed together in a server) as a first line of defence 
against targeted attacks. By reducing attacker's ability to get on the 
same server as the victim, attackers may have to go with trial-and-error
or brute-force solutions that can be very expensive with low yield. However, 
the encapsulation mechanisms are not perfect. A plethora of previous work, 
kick-started by Ristenpart et al.~\cite{ristenpartccs2009} a decade ago, have 
exploited various covert channels to enable co-residency detection on clouds 
like AWS, and used them to demonstrate targeted attacks or shed light on 
cloud's internal placement and resource allocation mechanisms\todo{cite} that 
further weaken the encapsulation. Clouds have since promptly fixed 
many of these covert channels and came up with containers that provide better 
isolation, like AWS Firecracker\cite{firecracker} for example. In this work,
we set out to prove that the job is not done yet.


% What's special about our technique
We found yet another way to detect coresidency among cloud instances (i.e., whether 
they are running on the same physical server), one which is more pervasive, reliable 
and harder to fix than with previous approaches. We use a covert channel 
based on memory bus hardware, first introduced by Wu et al.\cite{wuusenix2012}, 
which we show to be omni-present in all clouds. Unlike software-based covert 
channels that can be fixed with new releases, this one is inherent to x86 hardware
and is harder to fix. Finally, while previous approaches have made simplistic 
use of this covert channel\cite{varadarajan2015} due to noise and synchronization 
issues, we overcome these to communicate bits reliably over the channel that enabled 
us to achieve lightning-fast colocation detection for thousands of cloud instances.


% Why lambdas
In this work, we chose serverless functions as our cloud containers of choice.
Serverless functions have seen increased interest in recent years with most clouds 
providing these services, such as lambdas on AWS~\cite{awslambda} and cloud functions on GCP~\cite{gcpfunctions} (We use the terms lambdas, serverless functions and cloud instances 
interchangeably hereafter). They provide a more challenging environment for coresidence 
detection techniques based on covert channels as they usually have restricted runtimes 
that limit low-level code sometimes required to access such covert channels, and are more ephemeral (forcing the coresidence detection 
to be faster). They are also significantly cheaper, providing us a cost-effective way to demonstrate the technique. Note that whatever we are able to achieve with lambdas 
can be easily replicated with other traditional containers, as they are less, not more, 
restricted environments.


% Summary of what we did
In this paper, we only focus on \emph{cooperative} coresidence detection, to start with.
That is, all the lambdas are assumed to be in our/attacker's control. While this doesn't 
by itself help attacker target a victim, it can be used to perform targeted DDoS attacks \todo{cite power attacks?}
or learn cloud's internal mechanisms that may aid this. We propose a technique which, for given a set of lambdas deployed onto the cloud, can figure out which of them 
ran on the same server in the cloud. We show that we can do this with 100\% success 
rate for bigger lambdas and furthermore, we can do this within a minute for thousands 
of lambdas. We then perform a minor study on colocation patterns in various AWS 
regions with some insights on lambda activity. \todo{any other takeaways?} Through this,
we hope to motivate the need to address the memory bus covert channel in all the three clouds.


% Organization
The remainder of this paper is organized as follows. Section \ref{sec:background} presents some background from the literature. Sections \ref{sec:methodology} and \ref{sec:technique} present our co-residence detection mechanism in detail. We evaluate the mechanism in section \ref{sec:eval} and conclude with a placement study of AWS lambdas using our technique in section \ref{sec:study}.  


